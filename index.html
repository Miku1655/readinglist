<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Reading List</title>
<style>
body {
    font-family: system-ui, sans-serif;
    background: #111;
    color: #eee;
    padding: 20px;
}
h1 { font-size: 1.6em; margin-bottom: 6px; }
.tabs { display: flex; justify-content: flex-end; gap: 6px; margin-bottom: 12px; }
.tab { padding: 6px 12px; background: #1a1a1a; border: 1px solid #333; color: #ccc; cursor: pointer; }
.tab.active { background: #222; color: #fff; border-color: #555; }
.tab:hover { background: #2a2a2a; }
.tab-content { display: none; }
.tab-content.active { display: block; }
input, select, textarea { margin: 8px 0; padding: 6px; background: #222; color: #eee; border: 1px solid #444; }
button { margin-left: 8px; padding: 6px 10px; background: #222; color: #eee; border: 1px solid #444; cursor: pointer; }
button:hover { background: #2a2a2a; }
table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em; }
th, td { padding: 6px; border-bottom: 1px solid #333; text-align: left; }
th { background: #1a1a1a; cursor: pointer; user-select: none; }
tr:hover { background: #1f1f1f; }
.sort { margin-left: 4px; opacity: 0.6; }
.stats-upper { display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 20px; }
.stats-block { background: #1a1a1a; border: 1px solid #333; padding: 12px; flex: 1; min-width: 280px; max-height: 400px; overflow-y: auto; }
.stats-block h2 { margin: 0 0 10px 0; font-size: 1em; }
.stats-grid { display: grid; grid-template-columns: auto auto; gap: 4px 16px; }
.stats-list { font-size: 0.9em; }
.stats-year-block { background: #1a1a1a; border: 1px solid #333; padding: 12px; margin-bottom: 20px; }
#statsChartContainer { background: #1a1a1a; border: 1px solid #333; padding: 10px; border-radius: 6px; max-width: 100%; margin: 0 auto; }
#statsChart { width: 100%; height: 500px; }
.card-container { display: flex; flex-wrap: wrap; gap: 12px; }
.book-card { background:#222; padding:8px; border:1px solid #444; border-radius:6px; width:160px; height:auto; min-height:200px; text-align:center; cursor:pointer; position:relative; display:flex; flex-direction:column; }
.book-card:hover { background:#2a2a2a; }
.book-card.dragging { opacity: 0.5; z-index: 10; }
.book-card img { width:100%; height:140px; object-fit:contain; background:#1a1a1a; margin-bottom:8px; }
.book-card .no-cover { width:100%; height:140px; background:#1a1a1a; margin-bottom:8px; display:flex; align-items:center; justify-content:center; color:#666; font-size:0.8em; }
.book-card .profile-book-title { display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.95em; }
.book-card .profile-book-author { display: block; margin-top: 4px; font-size: 0.85em; color: #ccc; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.book-card small { display:block; margin-top:4px; font-size:0.8em; color:#ccc; }
.modal-footer { display: flex; justify-content: space-between; align-items: center; margin-top:12px; }
.modal-actions-right { display: flex; gap: 8px; }
button.danger { background-color: #8b2c2c; color: white; border: none; }
button.danger:hover { background-color: #a83838; }
#filterInfo { cursor: help; color: #888; }
#cloudButtons, #coverCloudButtons { margin-top: 12px; }
.profile-recent-section h4 { margin: 16px 0 8px 0; font-size:1em; }
/* New styles for edit modal */
.edit-section { background: #1a1a1a; padding: 12px; margin-bottom: 12px; border-radius: 6px; border: 1px solid #333; }
.edit-section h4 { margin: 0 0 10px 0; font-size: 1em; cursor: pointer; user-select: none; }
.edit-section.collapsed .edit-section-content { display: none; }
.read-entry { display: grid; grid-template-columns: 1fr 1fr auto; gap: 8px; align-items: center; margin-bottom: 8px; }
.read-entry button { background: #8b2c2c; padding: 4px 8px; font-size: 0.8em; }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>
<body>
<h1>Reading List</h1>
<div class="tabs">
    <button class="tab" data-tab="profile">Profile</button>
    <button class="tab active" data-tab="list">List</button>
    <button class="tab" data-tab="stats">Stats</button>
    <button class="tab" data-tab="timeline">Timeline</button>
    <button class="tab" data-tab="challenges">Challenges</button>
    <button class="tab" data-tab="options">Options</button>
</div>

<section id="tab-list" class="tab-content active">
    <label>Filter by shelf: <select id="shelfFilter"></select></label>
    <button id="sortRecent" style="margin-left: 12px;">Sort by recent <span id="recentSortIndicator">▼</span></button>
    <button id="addBook" style="margin-top:12px;">Add New Book</button>
    <label style="margin-left:15px">
        Search: <input type="text" id="searchInput" style="width:300px" placeholder="Search title, author, series or use filters">
        <span id="filterInfo">?</span>
    </label>
    <div id="yearGoalProgressContainer" style="margin:16px 0;"></div>
    <table>
        <thead>
            <tr>
                <th data-col="title">Title <span class="sort"></span></th>
                <th data-col="rating">Rating <span class="sort"></span></th>
                <th data-col="author">Author <span class="sort"></span></th>
                <th>Cover</th>
                <th data-col="shelves">Shelves <span class="sort"></span></th>
                <th data-col="pages">Pages <span class="sort"></span></th>
                <th data-col="year">Year <span class="sort"></span></th>
                <th data-col="lastRead">Last Read <span class="sort"></span></th>
                <th data-col="readCount">Reads <span class="sort"></span></th>
                <th>Edit</th>
            </tr>
        </thead>
        <tbody id="tableBody"></tbody>
    </table>
</section>

<section id="tab-stats" class="tab-content">
    <div id="stats"></div>
    <div id="statsChartContainer"><canvas id="statsChart"></canvas></div>
</section>

<section id="tab-timeline" class="tab-content">
    <div id="timelineContainer"></div>
</section>

<section id="tab-profile" class="tab-content">
    <div id="profileContainer" style="max-width:800px; margin:auto;">
        <div style="display:flex; gap:16px; align-items:center; margin-bottom:16px;">
            <div>
                <img id="profilePic" src="https://via.placeholder.com/100?text=?" alt="Profile Picture" style="width:100px;height:100px;object-fit:cover;border:2px solid #555; cursor:pointer; border-radius:50%;">
                <input type="file" id="profilePicInput" accept="image/*" style="display:none;">
            </div>
            <div style="flex:1;">
                <input type="text" id="profileNick" placeholder="Nickname" style="width:100%; margin-bottom:8px;">
                <textarea id="profileBio" placeholder="Bio" style="width:100%; height:80px; resize:vertical;"></textarea>
            </div>
        </div>
        <div id="profileStats"></div>
        <div class="profile-recent-section">
            <h3>Recent Activity</h3>
            <div id="recentBooksContainer" class="card-container"></div>
        </div>
        <div class="profile-recent-section">
            <h3>Favourites</h3>
            <div id="favouritesContainer" class="card-container"></div>
        </div>
    </div>
</section>

<section id="tab-challenges" class="tab-content">
    <h3>Yearly Goals</h3>
    <div id="goalsSection">
        <div class="goals-inline">
            <label>Year: <input type="number" id="goalYear" style="width:80px;"></label>
            <label>Books goal: <input type="number" id="yearBooksGoal" style="width:100px;"></label>
            <label>Pages goal: <input type="number" id="yearPagesGoal" style="width:100px;"></label>
            <button id="saveGoal">Save</button>
            <button id="removeGoal">Remove</button>
        </div>
    </div>
    <p style="margin-top:30px; color:#aaa;">Custom challenges (e.g. read by tag, author, etc.) coming in future updates!</p>
</section>

<section id="tab-options" class="tab-content">
    <h3>Import / Export</h3>
    <label>Import list: <input type="file" id="fileInput" accept=".csv,.json"></label>
    <button id="exportData">Export list</button>
    <button id="clearStorage" style="margin-left:12px;">Clear local list data</button>
    <hr style="border:1px solid #333; margin:16px 0;">
    <div id="generalSettings">
        <h3>General Settings</h3>
        <label><input type="checkbox" id="showNumbers" checked> Show row numbers</label><br><br>
        <label>Min books read for author avg rating: <input type="number" id="minAuthorBooks" min="1" value="2" style="width:80px;"></label><br><br>
        <label><input type="checkbox" id="showYearGoalProgress" checked> Show current year goal progress bar on List tab</label>
    </div>
    <div id="coversSection">
        <h3>Covers Management</h3>
        <p id="coversCount"></p>
        <label><input type="checkbox" id="showCoversTimeline"> Show book covers in Timeline tab</label><br><br>
        <button id="fetchAllCovers">Auto-fetch missing covers from Google Books</button><br><br>
        <button id="clearLocalCovers">Clear all local covers (irreversible)</button>
        <div id="coverCloudButtons" style="display:none;">
            <button id="saveCoversCloud">Save covers to Cloud</button>
            <button id="loadCoversCloud">Load covers from Cloud (overwrite local)</button>
            <button id="deleteCoversCloud" class="danger">Delete covers from Cloud</button>
        </div>
    </div>
    <hr style="border:1px solid #333; margin:16px 0;">
    <h3>Cloud Sync (Firebase - Manual only)</h3>
    <div id="syncStatus" style="margin-bottom:8px; color:#ccc;">Not signed in (local only)</div>
    <input type="email" id="authEmail" placeholder="Email" style="width:200px;"><br>
    <input type="password" id="authPassword" placeholder="Password" style="width:200px;"><br>
    <button id="signInBtn">Sign In</button>
    <button id="signUpBtn" style="margin-left:8px;">Sign Up</button>
    <button id="signOutBtn" style="display:none; margin-left:8px;">Sign Out</button>
    <div id="cloudButtons" style="display:none;">
        <button id="saveCloudBtn">Save to Cloud (overwrite cloud)</button>
        <button id="loadCloudBtn">Load from Cloud (overwrite local)</button>
    </div>
    <hr style="border:1px solid #333; margin:16px 0;">
    <h3>Manage Shelves</h3>
    <div id="shelfManager"></div>
    <hr style="border:1px solid #333; margin:16px 0;">
    Version 1.7 – tags, reading speeds, multi-read support, cleaner edit modal, Challenges tab
</section>

<div id="editModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); justify-content:center; align-items:center; z-index:1000;">
    <div style="background:#222; padding:20px; border:1px solid #444; max-width:600px; width:100%; max-height:90vh; overflow-y:auto;">
        <h3>Edit Book</h3>

        <div class="edit-section">
            <h4 onclick="this.parentElement.classList.toggle('collapsed')">Basic Info ▼</h4>
            <div class="edit-section-content">
                <label>Title: <input type="text" id="editTitle" style="width:100%;"></label><br>
                <label>Author: <input type="text" id="editAuthor" style="width:100%;"></label><br>
                <label>Series: <input type="text" id="editSeries" style="width:100%;"></label><br>
                <label>Series #: <input type="number" id="editSeriesNumber" step="0.1" style="width:140px;"></label><br>
                <label>Pages: <input type="number" id="editPages"></label><br>
                <label>Year: <input type="number" id="editYear"></label><br>
                <label>Rating (0-5): <input type="number" id="editRating" min="0" max="5"></label><br>
                <label>Favourite book: <input type="checkbox" id="editFavourite"></label><br>
                <label id="favSeriesLabel">Favourite series: <input type="checkbox" id="editFavouriteSeries"></label><br>
            </div>
        </div>

        <div class="edit-section">
            <h4 onclick="this.parentElement.classList.toggle('collapsed')">Metadata ▼</h4>
            <div class="edit-section-content">
                <label>Language: <input type="text" id="editLanguage" style="width:100%;"></label><br>
                <label>Country: <input type="text" id="editCountry" style="width:100%;"></label><br>
                <label>Genre: <input type="text" id="editGenre" style="width:100%;"></label><br>
                <label>Tags (comma separated): <input type="text" id="editTags" style="width:100%;"></label><br>
                <label>Shelves (comma separated): <input type="text" id="editShelves" style="width:100%;"></label><br>
                <label>Status:
                    <select id="editExclusiveShelf">
                        <option value="read">read</option>
                        <option value="currently-reading">currently-reading</option>
                        <option value="to-read">to-read</option>
                        <option value="dnf">dnf</option>
                    </select>
                </label><br>
            </div>
        </div>

        <div class="edit-section">
            <h4 onclick="this.parentElement.classList.toggle('collapsed')">Reads / Re-reads ▼</h4>
            <div class="edit-section-content">
                <div id="readsList"></div>
                <button id="addReadBtn">+ Add Read</button>
                <p style="font-size:0.85em; color:#aaa; margin-top:8px;">
                    Read count is auto-calculated from finished reads.<br>
                    Current read (if status = currently-reading) will have start date but no finish date.
                </p>
            </div>
        </div>

        <div class="edit-section">
            <h4 onclick="this.parentElement.classList.toggle('collapsed')">Cover & Notes ▼</h4>
            <div class="edit-section-content">
                <label>Cover URL: <input type="text" id="editCoverUrl" style="width:100%;"></label>
                <button id="fetchCoverBtn">Auto-fetch from Google Books</button>
                <div style="margin-top:8px;"><img id="coverPreview" style="max-height:250px; max-width:100%; border:1px solid #444;" alt="Cover preview"></div>
                <textarea id="editNotes" placeholder="Notes" style="width:100%; height:100px; resize:vertical; margin-top:12px;"></textarea>
            </div>
        </div>

        <div class="modal-footer">
            <button id="removeBook" class="danger">Remove</button>
            <div class="modal-actions-right">
                <button id="saveEdit">Save</button>
                <button id="closeEdit">Close</button>
            </div>
        </div>
    </div>
</div>

<script>
// Firebase config
const firebaseConfig = {
  apiKey: "AIzaSyA8UlXHK1HPSeKAuCfEquonyjnT24ZWjcA",
  authDomain: "readinglist-75c4a.firebaseapp.com",
  databaseURL: "https://readinglist-75c4a-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "readinglist-75c4a",
  storageBucket: "readinglist-75c4a.firebasestorage.app",
  messagingSenderId: "717466374536",
  appId: "1:717466374536:web:a331148d9d3c378dd0ea3d"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const auth = firebase.auth();

// Element references
const goalYear = document.getElementById("goalYear");
const yearBooksGoal = document.getElementById("yearBooksGoal");
const yearPagesGoal = document.getElementById("yearPagesGoal");
const cloudButtons = document.getElementById("cloudButtons");
const coverCloudButtons = document.getElementById("coverCloudButtons");
const minAuthorBooksInput = document.getElementById("minAuthorBooks");

// Global state & constants
let currentUser = null;
let userRef = null;
let editingBook = null;
let books = [];
let nextImportOrder = 1;
let sortState = { column: null, direction: 1 };
const STORAGE_KEY = "reading_list_data";
const SHOW_NUM_KEY = "reading_list_show_numbers";
const TAB_KEY = "reading_list_active_tab";
const GOALS_KEY = "reading_goals_per_year";
const SHELF_COLORS_KEY = "reading_shelf_colors";
const PROFILE_KEY = "reading_list_profile";
const MIN_AUTHOR_BOOKS_KEY = "reading_min_author_books";
const SHOW_COVERS_TIMELINE_KEY = "reading_show_covers_timeline";
const SHOW_YEAR_GOAL_PROGRESS_KEY = "reading_show_year_goal_progress";
let shelfColors = {};
let goals = {};
let profile = { favourites: [], favouriteSeries: [] };
let draggedElement = null;
let minAuthorBooks = 2;
let showCoversInTimeline = false;
let showYearGoalProgress = true;
let notePopup = null;

// New helpers for reads and activity
function getReadCount(book) {
    return book.reads ? book.reads.filter(r => r.finished !== null).length : 0;
}

function getLatestFinished(book) {
    if (!book.reads || book.reads.length === 0) return 0;
    const finished = book.reads.map(r => r.finished).filter(t => t !== null);
    return finished.length > 0 ? Math.max(...finished) : 0;
}

function getCurrentReadStart(book) {
    if (!book.reads || book.reads.length === 0) return 0;
    const current = book.reads.find(r => r.finished === null);
    return current ? current.started || 0 : 0;
}

function getActivityTimestamp(book) {
    const latestFinished = getLatestFinished(book);
    const currentStart = getCurrentReadStart(book);
    return Math.max(latestFinished, currentStart);
}

// Reading speed calculation
function calculateReadingSpeeds() {
    const validReads = [];
    books.forEach(book => {
        if (!book.reads || book.pages <= 0) return;
        book.reads.forEach(read => {
            if (read.started !== null && read.finished !== null) {
                const days = (read.finished - read.started) / (1000 * 60 * 60 * 24);
                if (days > 0) {
                    validReads.push({
                        book: book,
                        speed: book.pages / days,
                        days: days
                    });
                }
            }
        });
    });

    if (validReads.length === 0) {
        return { avg: "0", fastest: null, slowest: null };
    }

    const speeds = validReads.map(r => r.speed);
    const avg = (speeds.reduce((a, b) => a + b, 0) / speeds.length).toFixed(1);
    validReads.sort((a, b) => b.speed - a.speed);
    const fastest = validReads[0];
    const slowest = validReads[validReads.length - 1];

    return { avg, fastest, slowest };
}

// Cover fetch (unchanged)
async function fetchCover(book) {
    let query = "";
    if (book.isbn) {
        query = `isbn:${book.isbn}`;
    } else if (book.title) {
        query = `intitle:${encodeURIComponent(book.title)}`;
        if (book.author) query += `+inauthor:${encodeURIComponent(book.author)}`;
    } else {
        return null;
    }
    try {
        const resp = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${query}&maxResults=10`);
        if (!resp.ok) return null;
        const data = await resp.json();
        if (data.totalItems === 0) return null;
        for (const item of data.items || []) {
            const links = item.volumeInfo.imageLinks;
            if (links && (links.thumbnail || links.smallThumbnail)) {
                return (links.thumbnail || links.smallThumbnail).replace(/^http:/, 'https:');
            }
        }
        return null;
    } catch (e) {
        console.error(e);
        return null;
    }
}

// Card creation functions (unchanged)
function createBookCard(book) {
    const div = document.createElement("div");
    div.className = "book-card";
    div.dataset.bookId = book.importOrder;
    const coverHtml = book.coverUrl
        ? `<img src="${book.coverUrl}" alt="Cover" onerror="this.style.display='none'">`
        : `<div class="no-cover">No cover</div>`;
    div.innerHTML = `
        ${coverHtml}
        <strong class="profile-book-title">${book.title || "No title"}</strong>
        <span class="profile-book-author">${book.author || ""}</span>
    `;
    div.title = `${book.title} — ${book.author}`;
    div.addEventListener("click", () => openEditModal(book));
    return div;
}

function createSeriesCard(series) {
    let seriesBooks = books.filter(b => b.series === series);
    if (seriesBooks.length === 0) return null;
    seriesBooks = seriesBooks.sort((a, b) => (a.seriesNumber ?? Infinity) - (b.seriesNumber ?? Infinity));
    const firstCoverBook = seriesBooks.find(b => b.coverUrl);
    const author = seriesBooks[0].author || "Various";
    const count = seriesBooks.length;
    let coverHtml = `<div class="no-cover">Series</div>`;
    if (firstCoverBook) {
        coverHtml = `<img src="${firstCoverBook.coverUrl}" alt="Cover" onerror="this.style.display='none'">`;
    }
    const div = document.createElement("div");
    div.className = "book-card";
    div.innerHTML = `
        ${coverHtml}
        <strong class="profile-book-title">${series}</strong>
        <span class="profile-book-author">${author}</span>
        <small>${count} book${count > 1 ? 's' : ''}</small>
    `;
    div.title = `${series} (${count} books)`;
    return div;
}

// Draggable favourites (unchanged)
function makeFavouritesDraggable(container) {
    container.addEventListener("dragstart", e => {
        const card = e.target.closest(".book-card");
        if (card) {
            draggedElement = card;
            card.classList.add("dragging");
            e.dataTransfer.effectAllowed = "move";
        }
    });
    container.addEventListener("dragover", e => {
        e.preventDefault();
        const card = e.target.closest(".book-card");
        if (card && card !== draggedElement) {
            const rect = card.getBoundingClientRect();
            const next = (e.clientY - rect.top) > (rect.height / 2);
            if (next && card.nextSibling !== draggedElement) {
                container.insertBefore(draggedElement, card.nextSibling);
            } else if (!next && card !== draggedElement.nextSibling) {
                container.insertBefore(draggedElement, card);
            }
        }
    });
    container.addEventListener("dragend", () => {
        if (draggedElement) {
            draggedElement.classList.remove("dragging");
            profile.favourites = Array.from(container.querySelectorAll(".book-card")).map(c => Number(c.dataset.bookId));
            localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
            draggedElement = null;
        }
    });
    container.addEventListener("drop", e => e.preventDefault());
    container.addEventListener("touchstart", e => {
        if (e.touches.length === 1) {
            const card = e.target.closest(".book-card");
            if (card) {
                draggedElement = card;
                card.classList.add("dragging");
            }
        }
    }, {passive: true});
    container.addEventListener("touchmove", e => {
        if (!draggedElement) return;
        e.preventDefault();
        const touch = e.touches[0];
        const overElem = document.elementFromPoint(touch.clientX, touch.clientY);
        const card = overElem ? overElem.closest(".book-card") : null;
        if (card && card !== draggedElement) {
            const rect = card.getBoundingClientRect();
            if (touch.clientY > rect.top + rect.height / 2) {
                card.after(draggedElement);
            } else {
                card.before(draggedElement);
            }
        }
    }, {passive: false});
    container.addEventListener("touchend", () => {
        if (draggedElement) {
            draggedElement.classList.remove("dragging");
            profile.favourites = Array.from(container.querySelectorAll(".book-card")).map(c => Number(c.dataset.bookId));
            localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
            draggedElement = null;
        }
    });
}

// Note popup (unchanged)
function createNotePopup() {
    notePopup = document.createElement("div");
    notePopup.style.position = "absolute";
    notePopup.style.background = "#222";
    notePopup.style.color = "#eee";
    notePopup.style.padding = "8px";
    notePopup.style.border = "1px solid #444";
    notePopup.style.borderRadius = "4px";
    notePopup.style.zIndex = "3000";
    notePopup.style.display = "none";
    notePopup.style.maxWidth = "300px";
    notePopup.style.pointerEvents = "none";
    document.body.appendChild(notePopup);
}
function showNotePopup(popup, text) {
    popup.textContent = text;
    popup.style.display = "block";
    document.addEventListener("mousemove", moveNotePopup);
}
function hideNotePopup(popup) {
    popup.style.display = "none";
    document.removeEventListener("mousemove", moveNotePopup);
}
function moveNotePopup(e) {
    if (!notePopup) return;
    notePopup.style.left = (e.clientX + 15) + "px";
    notePopup.style.top = (e.clientY + 20) + "px";
}

// Auth listener (unchanged)
auth.onAuthStateChanged(user => {
    currentUser = user;
    const syncStatus = document.getElementById("syncStatus");
    const signInBtn = document.getElementById("signInBtn");
    const signUpBtn = document.getElementById("signUpBtn");
    const signOutBtn = document.getElementById("signOutBtn");
    if (user) {
        userRef = db.ref("users/" + user.uid);
        syncStatus.textContent = `Signed in as ${user.email} (manual sync)`;
        signInBtn.style.display = "none";
        signUpBtn.style.display = "none";
        signOutBtn.style.display = "inline-block";
        cloudButtons.style.display = "block";
        coverCloudButtons.style.display = "block";
    } else {
        userRef = null;
        syncStatus.textContent = "Not signed in (local only)";
        signInBtn.style.display = "inline-block";
        signUpBtn.style.display = "inline-block";
        signOutBtn.style.display = "none";
        cloudButtons.style.display = "none";
        coverCloudButtons.style.display = "none";
    }
    loadLocalData();
    renderAll();
});

// Load local data with migration to new format
function loadLocalData() {
    const savedBooks = localStorage.getItem(STORAGE_KEY);
    if (savedBooks) {
        try { books = JSON.parse(savedBooks); } catch { books = []; }
    } else {
        books = [];
    }
    let maxOrder = 0;
    books.forEach(b => {
        if (!b.importOrder) b.importOrder = nextImportOrder++;
        maxOrder = Math.max(maxOrder, b.importOrder ?? 0);

        // Migration from old format
        if (!Array.isArray(b.reads)) {
            b.reads = [];
            if (b.dateRead) {
                const finishDates = b.dateRead.split(",").map(d => d.trim()).filter(Boolean);
                finishDates.forEach(fd => {
                    const fTs = new Date(fd).getTime();
                    if (!isNaN(fTs)) {
                        b.reads.push({ started: b.dateStarted || null, finished: fTs });
                    }
                });
            }
            if (b.exclusiveShelf === "currently-reading" && b.dateStarted) {
                const sTs = new Date(b.dateStarted).getTime();
                if (!isNaN(sTs)) {
                    b.reads.push({ started: sTs, finished: null });
                }
            }
            delete b.dateRead;
            delete b.dateStarted;
            delete b.readCount;
            delete b.lastFinished;
        }

        // Ensure tags exist
        if (!Array.isArray(b.tags)) b.tags = [];
    });
    nextImportOrder = maxOrder + 1;

    const savedProfile = localStorage.getItem(PROFILE_KEY);
    profile = savedProfile ? JSON.parse(savedProfile) : { favourites: [], favouriteSeries: [] };
    profile.favourites = (profile.favourites || []).filter(id => typeof id === 'number' && books.some(b => b.importOrder === id));
    profile.favouriteSeries = (profile.favouriteSeries || []).filter(s => typeof s === 'string');

    goals = JSON.parse(localStorage.getItem(GOALS_KEY) || "{}");
    shelfColors = JSON.parse(localStorage.getItem(SHELF_COLORS_KEY) || "{}");

    document.getElementById("showNumbers").checked = JSON.parse(localStorage.getItem(SHOW_NUM_KEY) || "true");
    minAuthorBooks = Number(localStorage.getItem(MIN_AUTHOR_BOOKS_KEY)) || 2;
    minAuthorBooksInput.value = minAuthorBooks;
    showCoversInTimeline = JSON.parse(localStorage.getItem(SHOW_COVERS_TIMELINE_KEY) || "false");
    document.getElementById("showCoversTimeline").checked = showCoversInTimeline;
    showYearGoalProgress = JSON.parse(localStorage.getItem(SHOW_YEAR_GOAL_PROGRESS_KEY) || "true");
    document.getElementById("showYearGoalProgress").checked = showYearGoalProgress;

    document.getElementById("profileNick").value = profile.nick || "";
    document.getElementById("profileBio").value = profile.bio || "";
    if (profile.picture) document.getElementById("profilePic").src = profile.picture;

    loadGoalsForYear();
    updateCoversCount();
}

function saveBooksToLocal() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(books));
}

// Shelf filter (unchanged)
function populateShelfFilter() {
    const select = document.getElementById("shelfFilter");
    const currentValue = select.value;
    select.innerHTML = '<option value="all">all</option>';
    const set = new Set();
    books.forEach(b => {
        if (b.exclusiveShelf) set.add(b.exclusiveShelf);
        (b.shelves || []).forEach(s => set.add(s));
    });
    [...set].sort().forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        opt.textContent = s;
        select.appendChild(opt);
    });
    if (currentValue && currentValue !== "all" && [...set].includes(currentValue)) {
        select.value = currentValue;
    } else {
        select.value = "all";
    }
}

// Cloud operations (unchanged except full code)
document.getElementById("saveCloudBtn").addEventListener("click", () => {
    if (!currentUser) return alert("Sign in first");
    if (!confirm("Overwrite cloud data with current local data?")) return;
    const dataToSave = {
        books: books,
        profile: profile,
        goals: goals,
        shelfColors: shelfColors,
        settings: {
            showNumbers: document.getElementById("showNumbers").checked,
            minAuthorBooks: minAuthorBooks,
            showCoversTimeline: showCoversInTimeline,
            showYearGoalProgress: showYearGoalProgress
        }
    };
    userRef.set(dataToSave)
        .then(() => alert("Saved to cloud successfully!"))
        .catch(err => alert("Save failed: " + err.message));
});

document.getElementById("loadCloudBtn").addEventListener("click", () => {
    if (!currentUser) return alert("Sign in first");
    if (!confirm("Overwrite local data with cloud data? This cannot be undone.")) return;
    userRef.once("value")
        .then(snap => {
            const data = snap.val();
            if (!data) return alert("No data in cloud");
            let loadedBooks = data.books || [];
            if (!Array.isArray(loadedBooks)) loadedBooks = Object.values(loadedBooks);
            books = loadedBooks;
            loadLocalData(); // re-run migration and setup
            saveBooksToLocal();
            localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
            localStorage.setItem(GOALS_KEY, JSON.stringify(goals));
            localStorage.setItem(SHELF_COLORS_KEY, JSON.stringify(shelfColors));
            renderAll();
            alert("Loaded from cloud successfully!");
        })
        .catch(err => alert("Load failed: " + err.message));
});

// Covers operations (unchanged, full code)
document.getElementById("saveCoversCloud").addEventListener("click", () => {
    if (!currentUser) return alert("Sign in first");
    if (!confirm("Save covers to cloud (separate from main data)?")) return;
    const covers = {};
    books.forEach(b => {
        if (b.coverUrl) covers[b.importOrder] = b.coverUrl;
    });
    userRef.child("covers").set(covers)
        .then(() => alert("Covers saved to cloud!"))
        .catch(err => alert("Save failed: " + err.message));
});

document.getElementById("loadCoversCloud").addEventListener("click", () => {
    if (!currentUser) return alert("Sign in first");
    if (!confirm("Load covers from cloud? This will overwrite local covers.")) return;
    userRef.child("covers").once("value")
        .then(snap => {
            const covers = snap.val() || {};
            let changed = false;
            books.forEach(b => {
                const newUrl = covers[b.importOrder];
                if (newUrl !== b.coverUrl) {
                    b.coverUrl = newUrl || null;
                    changed = true;
                }
            });
            if (changed) {
                saveBooksToLocal();
                renderAll();
            }
            alert("Covers loaded!");
        })
        .catch(err => alert("Load failed: " + err.message));
});

document.getElementById("deleteCoversCloud").addEventListener("click", () => {
    if (!currentUser) return alert("Sign in first");
    if (!confirm("Delete all covers from cloud? This is irreversible.")) return;
    userRef.child("covers").remove()
        .then(() => alert("Covers deleted from cloud!"))
        .catch(err => alert("Delete failed: " + err.message));
});

document.getElementById("fetchAllCovers").addEventListener("click", async () => {
    const missing = books.filter(b => !b.coverUrl && b.title);
    if (missing.length === 0) return alert("No books are missing covers.");
    if (!confirm(`Auto-fetch covers for ${missing.length} book(s)? This may take a while.`)) return;
    let found = 0;
    for (const b of missing) {
        const url = await fetchCover(b);
        if (url) {
            b.coverUrl = url;
            found++;
            saveBooksToLocal();
            renderAll();
        }
        await new Promise(r => setTimeout(r, 800));
    }
    alert(`Done! Found covers for ${found} book(s).`);
});

document.getElementById("clearLocalCovers").addEventListener("click", () => {
    if (!confirm("Remove ALL cover URLs from local data? This is irreversible locally.")) return;
    books.forEach(b => b.coverUrl = null);
    saveBooksToLocal();
    renderAll();
    alert("All local covers cleared.");
});

function updateCoversCount() {
    const count = books.filter(b => b.coverUrl).length;
    const total = books.length;
    document.getElementById("coversCount").textContent =
        `${count} of ${total} books have covers (remote URLs – no disk space used by the app)`;
}

// Year goal progress (unchanged)
function renderYearGoalProgress() {
    const container = document.getElementById("yearGoalProgressContainer");
    container.innerHTML = "";
    if (!showYearGoalProgress) return;
    const currentYear = new Date().getFullYear();
    const perYear = calculatePerYear();
    const stats = perYear[currentYear] || { books: 0, pages: 0 };
    const goal = goals[currentYear] || {};
    if (!goal.books && !goal.pages) {
        container.innerHTML = `<div style="background:#1a1a1a;padding:12px;border:1px solid #333;border-radius:8px;"><p>No goals set for ${currentYear}.</p></div>`;
        return;
    }
    let html = `<div style="background:#1a1a1a;padding:16px;border:1px solid #333;border-radius:8px;"><h3>${currentYear} Goal Progress</h3>`;
    if (goal.books) {
        const percent = goal.books ? Math.min(100, Math.round(stats.books / goal.books * 100)) : 0;
        html += `<p>Books: ${stats.books} / ${goal.books} (${percent}%)</p>`;
        html += `<div style="background:#333;height:20px;border-radius:10px;overflow:hidden;margin-bottom:12px;">
                    <div style="background:#4caf50;width:${percent}%;height:100%;transition:width 0.4s;"></div>
                 </div>`;
    }
    if (goal.pages) {
        const percent = goal.pages ? Math.min(100, Math.round(stats.pages / goal.pages * 100)) : 0;
        html += `<p>Pages: ${stats.pages} / ${goal.pages} (${percent}%)</p>`;
        html += `<div style="background:#333;height:20px;border-radius:10px;overflow:hidden;">
                    <div style="background:#2196f3;width:${percent}%;height:100%;transition:width 0.4s;"></div>
                 </div>`;
    }
    html += `</div>`;
    container.innerHTML = html;
}

// Tab switching
function switchTab(name) {
    document.querySelectorAll(".tab").forEach(t => t.classList.toggle("active", t.dataset.tab === name));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.toggle("active", c.id === "tab-" + name));
    localStorage.setItem(TAB_KEY, name);
    if (name === "options") { renderShelfManager(); updateCoversCount(); }
    if (name === "stats") renderStats();
    if (name === "profile") {
        renderProfileStats();
        renderRecentBooks();
        renderFavourites();
    }
    if (name === "timeline") renderTimeline();
    if (name === "list") renderYearGoalProgress();
    if (name === "challenges") loadGoalsForYear();
    renderAll();
}

function renderAll() {
    populateShelfFilter();
    renderTable();
    renderStats();
    renderProfileStats();
    renderRecentBooks();
    renderFavourites();
    renderTimeline();
    renderYearGoalProgress();
    updateCoversCount();
    if (document.querySelector('.tab.active')?.dataset.tab === "options") renderShelfManager();
}

// Fixed openEditModal – no recreation on status change
function openEditModal(book = null) {
    editingBook = book || { reads: [], tags: [], exclusiveShelf: "to-read" };

    document.getElementById("editTitle").value = book?.title || "";
    document.getElementById("editAuthor").value = book?.author || "";
    document.getElementById("editSeries").value = book?.series || "";
    document.getElementById("editSeriesNumber").value = book?.seriesNumber ?? "";
    document.getElementById("editLanguage").value = book?.language || "";
    document.getElementById("editCountry").value = book?.country || "";
    document.getElementById("editGenre").value = book?.genre || "";
    document.getElementById("editTags").value = (book?.tags || []).join(", ");
    document.getElementById("editShelves").value = (book?.shelves || []).join(", ");
    document.getElementById("editExclusiveShelf").value = editingBook.exclusiveShelf || "to-read";
document.getElementById("editPages").value = book?.pages || "";
    document.getElementById("editYear").value = book?.year || "";
    document.getElementById("editRating").value = book?.rating || 0;
    document.getElementById("editNotes").value = book?.notes || "";
    document.getElementById("editCoverUrl").value = book?.coverUrl || "";

    const preview = document.getElementById("coverPreview");
    if (book?.coverUrl) {
        preview.src = book.coverUrl;
        preview.style.display = "block";
    } else {
        preview.style.display = "none";
    }

    document.getElementById("editFavourite").checked = !!book && profile.favourites.includes(book.importOrder);

    const series = book?.series || "";
    if (series) {
        document.getElementById("favSeriesLabel").style.display = "block";
        document.getElementById("editFavouriteSeries").checked = profile.favouriteSeries.includes(series);
    } else {
        document.getElementById("favSeriesLabel").style.display = "none";
    }

    // Build reads list
    const readsList = document.getElementById("readsList");
    readsList.innerHTML = "";
    const reads = editingBook.reads;

    function rebuildReadsList() {
        readsList.innerHTML = "";
        reads.forEach((read, idx) => {
            const div = document.createElement("div");
            div.className = "read-entry";
            div.innerHTML = `
                <input type="date" class="readStart" value="${read.started ? new Date(read.started).toISOString().substring(0,10) : ''}">
                <input type="date" class="readFinish" value="${read.finished ? new Date(read.finished).toISOString().substring(0,10) : ''}">
                <button type="button" class="removeRead">Remove</button>
            `;
            div.querySelector(".removeRead").onclick = () => {
                reads.splice(idx, 1);
                rebuildReadsList();
            };
            div.querySelector(".readStart").onchange = () => read.started = div.querySelector(".readStart").value ? new Date(div.querySelector(".readStart").value).getTime() : null;
            div.querySelector(".readFinish").onchange = () => read.finished = div.querySelector(".readFinish").value ? new Date(div.querySelector(".readFinish").value).getTime() : null;
            readsList.appendChild(div);
        });
    }

    rebuildReadsList();

    // Add read button
    document.getElementById("addReadBtn").onclick = () => {
        reads.push({ started: Date.now(), finished: null });
        rebuildReadsList();
    };

    // Status change – update reads list without recreating modal
    document.getElementById("editExclusiveShelf").onchange = () => {
        const status = document.getElementById("editExclusiveShelf").value;
        editingBook.exclusiveShelf = status;
        if (status === "currently-reading") {
            if (reads.length === 0 || reads[reads.length - 1].finished !== null) {
                reads.push({ started: Date.now(), finished: null });
            }
        } else if (status !== "read") {
            // Remove any open read
            reads = reads.filter(r => r.finished !== null);
        }
        rebuildReadsList();
    };

    document.getElementById("editModal").style.display = "flex";
}

// Fixed saveEdit – properly handles new books
document.getElementById("saveEdit").addEventListener("click", () => {
    const now = Date.now();

    const data = {
        title: document.getElementById("editTitle").value.trim(),
        author: document.getElementById("editAuthor").value.trim(),
        series: document.getElementById("editSeries").value.trim(),
        seriesNumber: document.getElementById("editSeriesNumber").value ? Number(document.getElementById("editSeriesNumber").value) : null,
        language: document.getElementById("editLanguage").value.trim() || null,
        country: document.getElementById("editCountry").value.trim() || null,
        genre: document.getElementById("editGenre").value.trim() || null,
        tags: document.getElementById("editTags").value.split(",").map(t => t.trim()).filter(Boolean),
        shelves: document.getElementById("editShelves").value.split(",").map(s => s.trim()).filter(Boolean),
        exclusiveShelf: document.getElementById("editExclusiveShelf").value,
        pages: Number(document.getElementById("editPages").value) || 0,
        year: Number(document.getElementById("editYear").value) || null,
        rating: Number(document.getElementById("editRating").value) || 0,
        notes: document.getElementById("editNotes").value.trim(),
        coverUrl: document.getElementById("editCoverUrl").value.trim() || null,
        reads: editingBook.reads.map(r => ({ started: r.started, finished: r.finished })) // copy
    };

    // Ensure currently-reading has open read
    if (data.exclusiveShelf === "currently-reading") {
        if (data.reads.length === 0 || data.reads[data.reads.length - 1].finished !== null) {
            data.reads.push({ started: now, finished: null });
        }
    } else if (data.exclusiveShelf !== "read") {
        data.reads = data.reads.filter(r => r.finished !== null);
    }

    let savedBook;
    if (editingBook && editingBook.importOrder) {
        // Existing book – update in place
        const index = books.findIndex(b => b.importOrder === editingBook.importOrder);
        if (index !== -1) {
            books[index] = { ...books[index], ...data };
            savedBook = books[index];
        }
    } else {
        // New book
        data.importOrder = nextImportOrder++;
        data.dateAdded = now;
        books.unshift(data);
        savedBook = data;
    }

    // Favourites handling (unchanged)
    const bookId = savedBook.importOrder;
    const isFav = document.getElementById("editFavourite").checked;
    if (isFav) {
        if (!profile.favourites.includes(bookId)) profile.favourites.push(bookId);
    } else {
        profile.favourites = profile.favourites.filter(id => id !== bookId);
    }
    const isFavSeries = document.getElementById("editFavouriteSeries").checked;
    if (isFavSeries && data.series && !profile.favouriteSeries.includes(data.series)) {
        profile.favouriteSeries.push(data.series);
    } else if (!isFavSeries && data.series) {
        profile.favouriteSeries = profile.favouriteSeries.filter(s => s !== data.series);
    }

    localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
    saveBooksToLocal();
    renderAll();
    closeEditModal();
});
// Search with tag support
function filterBooksByQuery(list, query) {
    const terms = query.toLowerCase().match(/\S+/g) || [];
    return list.filter(book => {
        let match = true;
        for (const term of terms) {
            let m;
            if ((m = term.match(/^rated([<>=!]+)?(\d+)$/))) {
                let op = m[1] || "=";
                const num = Number(m[2]);
                const val = book.rating ?? 0;
                if (op === ">") match = match && val > num;
                else if (op === ">=") match = match && val >= num;
                else if (op === "<") match = match && val < num;
                else if (op === "<=") match = match && val <= num;
                else if (op === "=" || op === "==") match = match && val === num;
                else if (op === "!=") match = match && val !== num;
            } else if ((m = term.match(/^pages([<>=!]+)?(\d+)$/i))) {
                let op = m[1] || "=";
                const num = Number(m[2]);
                const val = book.pages ?? 0;
                if (op === ">") match = match && val > num;
                else if (op === ">=") match = match && val >= num;
                else if (op === "<") match = match && val < num;
                else if (op === "<=") match = match && val <= num;
                else if (op === "=" || op === "==") match = match && val === num;
                else if (op === "!=") match = match && val !== num;
            } else if ((m = term.match(/^cover(=|:) *(true|1|false|0)$/i))) {
                const wantCover = m[2] === "true" || m[2] === "1";
                const hasCover = !!book.coverUrl;
                match = match && (hasCover === wantCover);
            } else if ((m = term.match(/^year([<>=!]+)?(-?\d+)$/i))) {
                let op = m[1] || "=";
                const num = Number(m[2]);
                if (book.year == null) { match = false; continue; }
                const val = book.year;
                if (op === ">") match = match && val > num;
                else if (op === ">=") match = match && val >= num;
                else if (op === "<") match = match && val < num;
                else if (op === "<=") match = match && val <= num;
                else if (op === "=" || op === "==") match = match && val === num;
                else if (op === "!=") match = match && val !== num;
            } else if ((m = term.match(/^lang(uage)?:?(.*)$/i))) {
                const val = m[2];
                if (val === "" || val === "none") {
                    match = match && !book.language;
                } else {
                    const lc = (book.language || "").toLowerCase();
                    match = match && lc.includes(val.toLowerCase());
                }
            } else if ((m = term.match(/^country?:?(.*)$/i))) {
                const val = m[1];
                if (val === "" || val === "none") {
                    match = match && !book.country;
                } else {
                    const lc = (book.country || "").toLowerCase();
                    match = match && lc.includes(val.toLowerCase());
                }
            } else if ((m = term.match(/^genre?:?(.*)$/i))) {
                const val = m[1];
                if (val === "" || val === "none") {
                    match = match && !book.genre;
                } else {
                    const lc = (book.genre || "").toLowerCase();
                    match = match && lc.includes(val.toLowerCase());
                }
            } else if ((m = term.match(/^tag:?(.*)$/i))) {
                const val = m[1];
                if (val === "" || val === "none") {
                    match = match && (!book.tags || book.tags.length === 0);
                } else {
                    const lcTags = (book.tags || []).map(t => t.toLowerCase());
                    match = match && lcTags.some(t => t.includes(val.toLowerCase()));
                }
            } else {
                const text = `${book.title} ${book.author} ${book.series || ""} ${book.notes || ""}`.toLowerCase();
                match = match && text.includes(term);
            }
            if (!match) return false;
        }
        return match;
    });
}

// Per-year calculation using reads
function calculatePerYear() {
    const perYear = {};
    books.forEach(b => {
        if (!b.reads) return;
        b.reads.forEach(read => {
            if (read.finished) {
                const dt = new Date(read.finished);
                const y = dt.getFullYear();
                perYear[y] = perYear[y] || { books: 0, pages: 0 };
                perYear[y].books++;
                perYear[y].pages += b.pages || 0;
            }
        });
    });
    return perYear;
}

// Table rendering (updated for reads)
function renderTable() {
    const showNumbers = document.getElementById("showNumbers").checked;
    const filter = document.getElementById("shelfFilter").value;
    const tbody = document.getElementById("tableBody");
    tbody.innerHTML = "";
    let list = books.slice();
    if (filter !== "all") {
        list = list.filter(b => b.exclusiveShelf === filter || (b.shelves || []).includes(filter));
    }
    const query = document.getElementById("searchInput").value.trim();
    if (query) list = filterBooksByQuery(list, query);
    if (sortState.column) {
        list.sort((a, b) => compare(a, b, sortState.column) * sortState.direction);
    } else {
        list.sort((a, b) => (getActivityTimestamp(b) - getActivityTimestamp(a)) * sortState.direction);
    }
    list.forEach((book, idx) => {
        const tr = document.createElement("tr");
        const shelvesDisplay = [book.exclusiveShelf, ...(book.shelves || [])].filter(Boolean)
            .map(sh => `<span style="background:${shelfColors[sh] || '#888'}; padding:2px 4px; margin-right:2px; border-radius:3px;">${sh}</span>`)
            .join("");
        const coverHtml = book.coverUrl ? `<img src="${book.coverUrl}" alt="Cover" style="max-height:80px;" onerror="this.style.display='none'">` : "";
        tr.innerHTML = `
            <td>${showNumbers ? (idx + 1) + ". " : ""}${book.title || ""}${book.notes ? ' <span class="noteIcon" style="cursor:help;color:#888;">📝</span>' : ''}</td>
            <td>${book.rating || "-"}</td>
            <td>${book.author || ""}</td>
            <td>${coverHtml}</td>
            <td>${shelvesDisplay}</td>
            <td>${book.pages || "-"}</td>
            <td>${book.year ?? "-"}</td>
            <td>${book.reads && book.reads.length > 0 ? new Date(getLatestFinished(book)).toLocaleDateString() : "-"}</td>
            <td>${getReadCount(book)}</td>
            <td>${getReadCount(book)}</td>
            <td><button class="editBtn" style="padding:2px 6px;">✎</button></td>
        `;
        tbody.appendChild(tr);
        tr.querySelector(".editBtn").addEventListener("click", () => openEditModal(book));
        if (book.notes) {
            const icon = tr.querySelector(".noteIcon");
            const popup = notePopup || createNotePopup();
            icon.addEventListener("mouseenter", () => showNotePopup(popup, book.notes));
            icon.addEventListener("mouseleave", () => hideNotePopup(popup));
        }
    });
}

// Fixed recent sort – fallback to dateAdded
function getActivityTimestamp(book) {
    const latestFinished = getLatestFinished(book);
    const currentStart = getCurrentReadStart(book);
    const added = book.dateAdded || 0;
    const bump = book.bumpTime || 0;
    return Math.max(latestFinished, currentStart, added, bump);
}

// Timeline using all finished reads
function renderTimeline() {
    const container = document.getElementById("timelineContainer");
    container.innerHTML = "";
    const entries = [];
    books.forEach(b => {
        if (b.reads) {
            b.reads.forEach(read => {
                if (read.finished) {
                    entries.push({ book: b, date: new Date(read.finished) });
                }
            });
        }
    });
    if (entries.length === 0) {
        container.innerHTML = "<p>No reading history yet.</p>";
        return;
    }
    entries.sort((a, b) => b.date - a.date);
    const groups = {};
    const userLocale = navigator.language || 'en-US';
    entries.forEach(entry => {
        const year = entry.date.getFullYear();
        const monthNum = entry.date.getMonth() + 1;
        const monthPadded = String(monthNum).padStart(2, '0');
        const monthName = entry.date.toLocaleString(userLocale, { month: 'long' });
        const key = `${year}-${monthPadded}`;
        if (!groups[key]) groups[key] = { display: `${year} ${monthName}`, entries: [] };
        groups[key].entries.push(entry);
    });
    const sortedKeys = Object.keys(groups).sort().reverse();
    sortedKeys.forEach(key => {
        const g = groups[key];
        const div = document.createElement("div");
        div.className = "timeline-entry";
        div.innerHTML = `<h4>${g.display} (${g.entries.length} read${g.entries.length > 1 ? 's' : ''})</h4>`;
        const ul = document.createElement("ul");
        g.entries.forEach(entry => {
            const li = document.createElement("li");
            if (showCoversInTimeline && entry.book.coverUrl) {
                const img = document.createElement("img");
                img.src = entry.book.coverUrl;
                img.alt = "Cover";
                img.onerror = () => img.style.display = 'none';
                li.appendChild(img);
            }
            const textDiv = document.createElement("div");
            const readDate = entry.date.toLocaleDateString(userLocale);
            textDiv.innerHTML = `<strong>${entry.book.title}</strong> by ${entry.book.author || "Unknown"} (${entry.book.rating || "unrated"}) — finished ${readDate}`;
            li.appendChild(textDiv);
            ul.appendChild(li);
        });
        div.appendChild(ul);
        container.appendChild(div);
    });
}

// Stats with reading speed
function renderStats() {
    const container = document.getElementById("stats");
    const ctx = document.getElementById("statsChart").getContext("2d");
    if (window.statsChart && typeof window.statsChart.destroy === 'function') {
        window.statsChart.destroy();
    }
    window.statsChart = null;
    const perYear = calculatePerYear();
    const readBooks = books.filter(b => b.exclusiveShelf === "read");
    const dnfBooks = books.filter(b => b.exclusiveShelf === "dnf");
    const pagesRead = readBooks.reduce((s, b) => s + (b.pages || 0) * getReadCount(b), 0);
    const selectedYear = Number(goalYear.value) || new Date().getFullYear();
    const currentPages = perYear[selectedYear]?.pages || 0;
    const currentBooks = perYear[selectedYear]?.books || 0;
    const pagesGoal = goals[selectedYear]?.pages || 0;
    const booksGoal = goals[selectedYear]?.books || 0;
    const authorStats = {};
    readBooks.forEach(b => {
        const auth = b.author || "Unknown";
        if (!authorStats[auth]) authorStats[auth] = { count: 0, ratingSum: 0, rated: 0 };
        authorStats[auth].count++;
        if (b.rating > 0) {
            authorStats[auth].ratingSum += b.rating;
            authorStats[auth].rated++;
        }
    });
    const topByCount = Object.entries(authorStats).sort((a, b) => b[1].count - a[1].count).slice(0, 10);
    const topByAvg = Object.entries(authorStats)
        .filter(([, s]) => s.count >= minAuthorBooks && s.rated > 0)
        .map(([a, s]) => [a, (s.ratingSum / s.rated).toFixed(2), s.rated])
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
    let longest = null, shortest = null, mostReread = null;
    let maxYearBooks = 0, maxYearPages = 0, maxYearBooksYear = null, maxYearPagesYear = null;
    readBooks.forEach(b => {
        if (!longest || b.pages > longest.pages) longest = b;
        if (!shortest || (b.pages > 0 && b.pages < shortest.pages)) shortest = b;
        if (!mostReread || getReadCount(b) > getReadCount(mostReread || {})) mostReread = b;
    });
    Object.entries(perYear).forEach(([y, s]) => {
        if (s.books > maxYearBooks) { maxYearBooks = s.books; maxYearBooksYear = y; }
        if (s.pages > maxYearPages) { maxYearPages = s.pages; maxYearPagesYear = y; }
    });

    const speeds = calculateReadingSpeeds();

    let html = '<div class="stats-upper">';
    html += '<div class="stats-block"><h2>Overall Stats</h2>';
    if (pagesGoal || booksGoal) {
        html += `<div style="background:#222; padding:12px; margin-bottom:12px; border-radius:6px;">
            <strong>${selectedYear} Goals</strong><br>
            ${booksGoal ? `Books: ${currentBooks} / ${booksGoal}<br>` : ""}
            ${pagesGoal ? `Pages: ${currentPages} / ${pagesGoal}` : ""}
        </div>`;
    }
    html += '<div class="stats-grid">';
    html += `<div>Total books</div><div>${books.length || 0}</div>`;
    html += `<div>Read</div><div>${readBooks.length}</div>`;
    html += `<div>DNF</div><div>${dnfBooks.length}</div>`;
    html += `<div>Pages read (× count)</div><div>${pagesRead}</div>`;
    html += '</div></div>';

    html += '<div class="stats-block"><h2>Favorite Authors</h2><div class="stats-list">';
    html += '<strong>By books read:</strong><br>';
    topByCount.forEach(([a, s]) => html += `• ${a}: ${s.count} book${s.count > 1 ? 's' : ''}<br>`);
    html += `<br><strong>By average rating (min ${minAuthorBooks} books):</strong><br>`;
    if (topByAvg.length === 0) html += "No authors meet minimum<br>";
    topByAvg.forEach(([a, avg, rated]) => html += `• ${a}: ${avg} (${rated} rated)<br>`);
    html += '</div></div>';

    html += '<div class="stats-block"><h2>Personal Records</h2><div class="stats-list">';
    if (longest) html += `Longest book: <strong>${longest.title}</strong> (${longest.pages} pages)<br>`;
    if (shortest) html += `Shortest book: <strong>${shortest.title}</strong> (${shortest.pages} pages)<br>`;
    if (mostReread && getReadCount(mostReread) > 1) html += `Most re-read: <strong>${mostReread.title}</strong> (${getReadCount(mostReread)} times)<br>`;
    if (maxYearBooksYear) html += `Most books in a year: ${maxYearBooks} (${maxYearBooksYear})<br>`;
    if (maxYearPagesYear) html += `Most pages in a year: ${maxYearPages} (${maxYearPagesYear})<br>`;
    html += '</div></div>';

    // Reading speed block
    html += '<div class="stats-block"><h2>Reading Speed</h2><div class="stats-list">';
    html += `<strong>Average:</strong> ${speeds.avg} pages/day<br>`;
    if (speeds.fastest) {
        html += `<strong>Fastest:</strong> ${speeds.fastest.book.title} (${speeds.fastest.speed.toFixed(1)} p/d over ${speeds.fastest.days.toFixed(1)} days)<br>`;
    }
    if (speeds.slowest) {
        html += `<strong>Slowest:</strong> ${speeds.slowest.book.title} (${speeds.slowest.speed.toFixed(1)} p/d over ${speeds.slowest.days.toFixed(1)} days)<br>`;
    }
    html += '</div></div>';

    html += '</div>';

    html += '<div class="stats-year-block"><h2>By Year</h2><div class="stats-list">';
    if (Object.keys(perYear).length === 0) {
        html += "none";
    } else {
        Object.keys(perYear).sort((a, b) => b - a).forEach(y => {
            html += `${y}: ${perYear[y].books} books, ${perYear[y].pages} pages<br>`;
        });
    }
    html += '</div></div>';

    container.innerHTML = html;

    const labels = Object.keys(perYear).sort((a,b) => a - b);
    if (labels.length === 0) return;
    const booksData = labels.map(y => perYear[y].books);
    const pagesData = labels.map(y => perYear[y].pages);
    window.statsChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [
            { label: 'Books', data: booksData, backgroundColor: 'rgba(75, 192, 192, 0.6)', yAxisID: 'y' },
            { label: 'Pages', data: pagesData, backgroundColor: 'rgba(153, 102, 255, 0.6)', yAxisID: 'y1' }
        ]},
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, position: 'left', ticks: { color: '#eee' }, grid: { color: '#333' } },
                y1: { beginAtZero: true, position: 'right', ticks: { color: '#eee' }, grid: { drawOnChartArea: false } }
            },
            plugins: { legend: { labels: { color: '#eee' } } }
        }
    });
}

// Profile stats (updated for read count)
function renderProfileStats() {
    const container = document.getElementById("profileStats");
    const readBooks = books.filter(b => b.exclusiveShelf === "read");
    const ratedBooks = readBooks.filter(b => b.rating > 0);
    const pagesRead = readBooks.reduce((s, b) => s + (b.pages || 0) * getReadCount(b), 0);
    const avgRating = ratedBooks.length ? (ratedBooks.reduce((s, b) => s + b.rating, 0) / ratedBooks.length).toFixed(1) : "-";
    container.innerHTML = `
        <h2>Reading Stats</h2>
        <div class="stats-grid">
            <div>Books read</div><div>${readBooks.length}</div>
            <div>Pages read</div><div>${pagesRead}</div>
            <div>Average rating</div><div>${avgRating}</div>
        </div>
    `;
}

// Shelf manager (unchanged)
function renderShelfManager() {
    const container = document.getElementById("shelfManager");
    container.innerHTML = "";
    const set = new Set();
    books.forEach(b => (b.shelves || []).forEach(s => set.add(s)));
    [...set].sort().forEach(shelf => {
        const div = document.createElement("div");
        div.style.marginBottom = "8px";
        div.innerHTML = `
            <input type="text" value="${shelf}" style="width:150px;" class="shelfName">
            <input type="color" value="${shelfColors[shelf] || '#888888'}" class="shelfColor">
            <button class="renameShelf">Rename</button>
            <button class="deleteShelf">Delete</button>
        `;
        container.appendChild(div);
        div.querySelector(".shelfColor").addEventListener("input", e => {
            shelfColors[shelf] = e.target.value;
            localStorage.setItem(SHELF_COLORS_KEY, JSON.stringify(shelfColors));
            renderTable();
        });
        div.querySelector(".renameShelf").addEventListener("click", () => {
            const newName = div.querySelector(".shelfName").value.trim();
            if (!newName || newName === shelf) return;
            if (!confirm(`Rename "${shelf}" → "${newName}" everywhere?`)) return;
            books.forEach(b => {
                if (b.shelves) b.shelves = b.shelves.map(s => s === shelf ? newName : s);
            });
            shelfColors[newName] = shelfColors[shelf] || '#888888';
            delete shelfColors[shelf];
            localStorage.setItem(SHELF_COLORS_KEY, JSON.stringify(shelfColors));
            saveBooksToLocal();
            renderAll();
        });
        div.querySelector(".deleteShelf").addEventListener("click", () => {
            if (!confirm(`Remove shelf "${shelf}" from all books?`)) return;
            books.forEach(b => {
                if (b.shelves) b.shelves = b.shelves.filter(s => s !== shelf);
            });
            delete shelfColors[shelf];
            localStorage.setItem(SHELF_COLORS_KEY, JSON.stringify(shelfColors));
            saveBooksToLocal();
            renderAll();
        });
    });
}

// Recent books (unchanged)
function renderRecentBooks() {
    const container = document.getElementById("recentBooksContainer");
    container.innerHTML = "";
    const sortDesc = (a, b) => getActivityTimestamp(b) - getActivityTimestamp(a);
    let currently = books.filter(b => b.exclusiveShelf === "currently-reading");
    if (currently.length) {
        const section = document.createElement("div");
        section.innerHTML = "<h4>Currently Reading</h4><div class=\"card-container\"></div>";
        container.appendChild(section);
        currently.sort(sortDesc).forEach(b => section.querySelector(".card-container").appendChild(createBookCard(b)));
    }
    let finished = books.filter(b => b.exclusiveShelf === "read" && getLatestFinished(b) > 0);
    if (finished.length) {
        const section = document.createElement("div");
        section.innerHTML = "<h4>Recently Finished</h4><div class=\"card-container\"></div>";
        container.appendChild(section);
        finished.sort(sortDesc).slice(0, 8).forEach(b => section.querySelector(".card-container").appendChild(createBookCard(b)));
    }
    let toread = books.filter(b => b.exclusiveShelf === "to-read");
    if (toread.length) {
        const section = document.createElement("div");
        section.innerHTML = "<h4>Recently Added to To-Read</h4><div class=\"card-container\"></div>";
        container.appendChild(section);
        toread.sort(sortDesc).slice(0, 4).forEach(b => section.querySelector(".card-container").appendChild(createBookCard(b)));
    }
    if (!container.innerHTML.trim()) container.innerHTML = "<p>No activity yet.</p>";
}

// Favourites (unchanged)
function renderFavourites() {
    const container = document.getElementById("favouritesContainer");
    container.innerHTML = "";
    let hasContent = false;
    if (profile.favouriteSeries.length) {
        const section = document.createElement("div");
        section.innerHTML = "<h4>Favourite Series</h4><div class=\"card-container\"></div>";
        container.appendChild(section);
        profile.favouriteSeries.sort().forEach(series => {
            const card = createSeriesCard(series);
            if (card) {
                hasContent = true;
                section.querySelector(".card-container").appendChild(card);
            }
        });
    }
    if (profile.favourites.length) {
        const favBooks = profile.favourites.map(id => books.find(b => b.importOrder === id)).filter(Boolean);
        if (favBooks.length) {
            hasContent = true;
            const section = document.createElement("div");
            section.innerHTML = "<h4>Favourite Books</h4><div class=\"card-container\"></div>";
            container.appendChild(section);
            const favContainer = section.querySelector(".card-container");
            favBooks.forEach(book => {
                const card = createBookCard(book);
                card.draggable = true;
                favContainer.appendChild(card);
            });
            makeFavouritesDraggable(favContainer);
        }
    }
    if (!hasContent) container.innerHTML = "<p>No favourites yet.</p>";
}

// Goals functions (unchanged)
function loadGoalsForYear() {
    const year = Number(goalYear.value) || new Date().getFullYear();
    goalYear.value = year;
    const g = goals[year] || {};
    yearPagesGoal.value = g.pages || "";
    yearBooksGoal.value = g.books || "";
}

goalYear.addEventListener("change", () => {
    loadGoalsForYear();
    renderStats();
});

document.getElementById("saveGoal").addEventListener("click", () => {
    const year = Number(goalYear.value) || new Date().getFullYear();
    const pages = Number(yearPagesGoal.value) || 0;
    const booksGoal = Number(yearBooksGoal.value) || 0;
    if (pages || booksGoal) {
        goals[year] = { pages, books: booksGoal };
    } else {
        delete goals[year];
    }
    localStorage.setItem(GOALS_KEY, JSON.stringify(goals));
    renderStats();
});

document.getElementById("removeGoal").addEventListener("click", () => {
    const year = Number(goalYear.value);
    if (goals[year] && confirm(`Remove goals for ${year}?`)) {
        delete goals[year];
        localStorage.setItem(GOALS_KEY, JSON.stringify(goals));
        loadGoalsForYear();
        renderStats();
    }
});

minAuthorBooksInput.addEventListener("change", () => {
    minAuthorBooks = Math.max(1, Number(minAuthorBooksInput.value) || 2);
    localStorage.setItem(MIN_AUTHOR_BOOKS_KEY, minAuthorBooks);
    renderStats();
});

document.getElementById("showCoversTimeline").addEventListener("change", e => {
    showCoversInTimeline = e.target.checked;
    localStorage.setItem(SHOW_COVERS_TIMELINE_KEY, JSON.stringify(showCoversInTimeline));
    renderTimeline();
});

// Sorting comparison (updated for readCount)
function compare(a, b, col) {
    let av = a[col];
    let bv = b[col];
    if (col === "year") {
        av = av ?? Infinity;
        bv = bv ?? Infinity;
        return av - bv;
    }
    if (col === "pages" || col === "rating") {
        av = av ?? 0;
        bv = bv ?? 0;
        return av - bv;
    }
    if (col === "lastRead") {
        return getLatestFinished(a) - getLatestFinished(b);
    }
    if (col === "readCount") {
        av = getReadCount(a);
        bv = getReadCount(b);
        return av - bv;
    }
    if (col === "shelves") {
        av = [a.exclusiveShelf, ...(a.shelves || [])].join(", ");
        bv = [b.exclusiveShelf, ...(b.shelves || [])].join(", ");
    }
    av = av ?? "";
    bv = bv ?? "";
    return String(av).localeCompare(String(bv));
}

function handleSort(col) {
    if (sortState.column === col) {
        sortState.direction *= -1;
    } else {
        sortState.column = col;
        sortState.direction = 1;
    }
    updateSortIndicators();
    renderTable();
}

function updateSortIndicators() {
    document.querySelectorAll(".sort").forEach(s => s.textContent = "");
    document.getElementById("recentSortIndicator").textContent = "";
    if (sortState.column) {
        const el = document.querySelector(`th[data-col="${sortState.column}"] .sort`);
        if (el) el.textContent = sortState.direction > 0 ? "▲" : "▼";
    } else {
        document.getElementById("recentSortIndicator").textContent = sortState.direction > 0 ? "▼" : "▲";
    }
}

// Event listeners (full)
document.querySelectorAll(".tab").forEach(btn => btn.addEventListener("click", () => switchTab(btn.dataset.tab)));
document.getElementById("addBook").addEventListener("click", () => openEditModal());
document.getElementById("searchInput").addEventListener("input", renderTable);
document.getElementById("shelfFilter").addEventListener("change", renderTable);
document.querySelectorAll("th[data-col]").forEach(th => th.addEventListener("click", () => handleSort(th.dataset.col)));
document.getElementById("sortRecent").addEventListener("click", () => {
    if (sortState.column === null) {
        sortState.direction *= -1;
    } else {
        sortState.column = null;
        sortState.direction = 1;
    }
    updateSortIndicators();
    renderTable();
});
document.getElementById("fileInput").addEventListener("change", e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        if (file.name.endsWith(".json")) importJSON(ev.target.result);
        else parseCSV(ev.target.result);
    };
    reader.readAsText(file);
});
document.getElementById("exportData").addEventListener("click", () => {
    const data = { books };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "reading-list-export.json";
    a.click();
    URL.revokeObjectURL(url);
});
document.getElementById("clearStorage").addEventListener("click", () => {
    if (confirm("Clear all local data? (Cloud data stays if signed in)")) {
        localStorage.clear();
        books = [];
        profile = { favourites: [], favouriteSeries: [] };
        goals = {};
        shelfColors = {};
        loadLocalData();
        renderAll();
    }
});
document.getElementById("signInBtn").addEventListener("click", () => {
    const email = document.getElementById("authEmail").value.trim();
    const pass = document.getElementById("authPassword").value;
    if (!email || !pass) return alert("Enter email and password");
    auth.signInWithEmailAndPassword(email, pass).catch(err => alert("Sign in error: " + err.message));
});
document.getElementById("signUpBtn").addEventListener("click", () => {
    const email = document.getElementById("authEmail").value.trim();
    const pass = document.getElementById("authPassword").value;
    if (!email || !pass) return alert("Enter email and password");
    auth.createUserWithEmailAndPassword(email, pass).catch(err => alert("Sign up error: " + err.message));
});
document.getElementById("signOutBtn").addEventListener("click", () => auth.signOut());
document.getElementById("showNumbers").addEventListener("change", () => {
    localStorage.setItem(SHOW_NUM_KEY, document.getElementById("showNumbers").checked);
    renderTable();
});
document.getElementById("profilePic").addEventListener("click", () => document.getElementById("profilePicInput").click());
document.getElementById("profilePicInput").addEventListener("change", e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        profile.picture = ev.target.result;
        document.getElementById("profilePic").src = profile.picture;
        localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
    };
    reader.readAsDataURL(file);
});
let profileSaveTimeout;
document.getElementById("profileNick").addEventListener("input", () => {
    clearTimeout(profileSaveTimeout);
    profileSaveTimeout = setTimeout(() => {
        profile.nick = document.getElementById("profileNick").value.trim();
        localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
    }, 800);
});
document.getElementById("profileBio").addEventListener("input", () => {
    clearTimeout(profileSaveTimeout);
    profileSaveTimeout = setTimeout(() => {
        profile.bio = document.getElementById("profileBio").value.trim();
        localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
    }, 800);
});
document.getElementById("removeBook").addEventListener("click", () => {
    if (!editingBook || !confirm("Really remove this book?")) return;
    profile.favourites = profile.favourites.filter(id => id !== editingBook.importOrder);
    localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
    books = books.filter(b => b !== editingBook);
    saveBooksToLocal();
    renderAll();
    closeEditModal();
});
document.getElementById("showYearGoalProgress").addEventListener("change", e => {
    showYearGoalProgress = e.target.checked;
    localStorage.setItem(SHOW_YEAR_GOAL_PROGRESS_KEY, JSON.stringify(showYearGoalProgress));
    renderYearGoalProgress();
});
document.getElementById("closeEdit").addEventListener("click", closeEditModal);
document.getElementById("editModal").addEventListener("click", e => {
    if (e.target === document.getElementById("editModal")) closeEditModal();
});
document.getElementById("fetchCoverBtn").addEventListener("click", async () => {
    const title = document.getElementById("editTitle").value.trim();
    if (!title) return alert("Enter a title first.");
    const tempBook = {
        title: title,
        author: document.getElementById("editAuthor").value.trim()
    };
    const url = await fetchCover(tempBook);
    const preview = document.getElementById("coverPreview");
    if (url) {
        document.getElementById("editCoverUrl").value = url;
        preview.src = url;
        preview.style.display = "block";
    } else {
        alert("No cover found for this book.");
    }
});
document.getElementById("filterInfo").addEventListener("click", () => {
    alert(`Search syntax:
• Normal words → title / author / series / notes
• rated>3 rated=0 (unrated) rated>=4 etc.
• pages>300 pages<=100 pages=500
• year>=-50 year<10 year=-500 (negative = BC)
• cover=true/false or cover=1/0
• lang:english, language:jap, lang:none
• country:japan, country:usa, country:none
• genre:fantasy, genre:mystery, genre:none
• tag:mood, tag:prize, tag:none
• added:2024, added>2023-06-01, added:none
Combine with spaces (AND).`);
});

// Import helpers (unchanged)
function parseCSVLine(line) {
    const result = [];
    let field = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
        const c = line[i];
        if (c === '"') inQuotes = !inQuotes;
        else if (c === "," && !inQuotes) {
            result.push(field);
            field = "";
        } else field += c;
    }
    result.push(field);
    return result;
}
function parseCSV(text) {
    const lines = text.split(/\r?\n/).filter(l => l.trim());
    if (!lines.length) return;
    const headers = lines[0].split(",").map(h => h.replace(/^"|"$/g, "").trim());
    const idx = name => headers.findIndex(h => h === name);
    books = [];
    nextImportOrder = 1;
    for (let i = 1; i < lines.length; i++) {
        const cols = parseCSVLine(lines[i]);
        if (!cols[idx("Title")]) continue;
        const exclusive = cols[idx("Exclusive Shelf")] || "read";
        let extraShelves = cols[idx("Bookshelves")] ? cols[idx("Bookshelves")].split(",").map(s => s.trim()) : [];
        extraShelves = extraShelves.filter(s => s !== exclusive);
        const isbnCol = headers.findIndex(h => h.toLowerCase() === "isbn" || h.toLowerCase() === "isbn13");
        let isbn = "";
        if (isbnCol !== -1 && cols[isbnCol]) {
            isbn = cols[isbnCol].replace(/[^0-9X]/gi, "");
        }
        const book = {
            title: cols[idx("Title")],
            author: cols[idx("Author")],
            series: cols[idx("Series")] || "",
            exclusiveShelf: exclusive,
            shelves: extraShelves,
            pages: Number(cols[idx("Number of Pages")]) || 0,
            year: Number(cols[idx("Original Publication Year")]) || null,
            rating: Number(cols[idx("My Rating")]) || 0,
            notes: cols[idx("My Review")] || "",
            importOrder: nextImportOrder++,
            dateAdded: Date.now(),
            isbn: isbn || null,
            reads: [],
            tags: []
        };
        books.push(book);
    }
    saveBooksToLocal();
    renderAll();
}
function importJSON(text) {
    let data;
    try { data = JSON.parse(text); } catch { return alert("Invalid JSON"); }
    if (!data.books || !Array.isArray(data.books)) return alert("Invalid export");
    if (!confirm("Import will replace current list. Continue?")) return;
    books = data.books;
    loadLocalData();
    saveBooksToLocal();
    renderAll();
}

// Initial setup
loadLocalData();
const savedTab = localStorage.getItem(TAB_KEY) || "list";
switchTab(savedTab);
renderAll();
goalYear.value = new Date().getFullYear();
loadGoalsForYear();
</script>
</body>
</html>
